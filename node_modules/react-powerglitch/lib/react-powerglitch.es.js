import { useState as d, useCallback as E } from "react";
var w = Object.defineProperty, G = Object.defineProperties, M = Object.getOwnPropertyDescriptors, g = Object.getOwnPropertySymbols, k = Object.prototype.hasOwnProperty, O = Object.prototype.propertyIsEnumerable, f = (e, t, i) => t in e ? w(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, u = (e, t) => {
  for (var i in t || (t = {}))
    k.call(t, i) && f(e, i, t[i]);
  if (g)
    for (var i of g(t))
      O.call(t, i) && f(e, i, t[i]);
  return e;
}, S = (e, t) => G(e, M(t));
const y = (e = "always") => ({ playMode: e, optimizeSeo: !0, createContainers: !0, hideOverflow: !1, timing: e === "always" ? { duration: 2 * 1e3, iterations: 1 / 0 } : { duration: 250, iterations: 1 }, glitchTimeSpan: e === "always" ? { start: 0.5, end: 0.7 } : { start: 0, end: 1 }, shake: { velocity: 15, amplitudeX: 0.2, amplitudeY: 0.2 }, slice: e === "click" ? { count: 15, velocity: 20, minHeight: 0.02, maxHeight: 0.15, hueRotate: !0 } : { count: 6, velocity: 15, minHeight: 0.02, maxHeight: 0.15, hueRotate: !0 }, pulse: !1 }), v = (e, t) => {
  if (!e.glitchTimeSpan)
    return 1;
  const i = e.glitchTimeSpan.start, r = e.glitchTimeSpan.end;
  if (t < i || t > r)
    return 0;
  const n = i + (r - i) / 2;
  return t < n ? (t - i) / (n - i) : (r - t) / (r - n);
}, m = (e, t) => (Math.random() - 0.5) * 2 * v(e, t), C = ({ minHeight: e, maxHeight: t, minWidth: i, maxWidth: r }) => {
  const n = Math.floor(Math.random() * ((t - e) * 100 + 1)) + e * 100, o = Math.floor(Math.random() * ((r - i) * 100 + 1)) + i * 100, a = Math.floor(Math.random() * (100 - n)), l = Math.floor(Math.random() * (100 - o)), c = `${l + o}% ${a}%`, s = `${l + o}% ${a + n}%`, h = `${l}% ${a + n}%`, p = `${l}% ${a}%`;
  return `polygon(${c},${s},${h},${p})`;
}, H = (e) => {
  const t = Math.floor(e.slice.velocity * e.timing.duration / 1e3) + 1, i = [];
  for (let r = 0; r < t; ++r) {
    if (v(e, r / t) === 0) {
      i.push({ opacity: "0", transform: "none", clipPath: "unset" });
      continue;
    }
    const n = { opacity: "1", transform: `translate3d(${m(e, r / t) * 30}%,0,0)`, clipPath: C({ minHeight: e.slice.minHeight, maxHeight: e.slice.maxHeight, minWidth: 1, maxWidth: 1 }) };
    e.slice.hueRotate && (n.filter = `hue-rotate(${Math.floor(m(e, r / t) * 360)}deg)`), i.push(n);
  }
  return { steps: i, timing: u({ easing: `steps(${t},jump-start)` }, e.timing) };
}, A = (e) => e.pulse ? { steps: [{ transform: "scale(1)", opacity: "1" }, { transform: `scale(${e.pulse.scale})`, opacity: "0" }], timing: S(u({}, e.timing), { delay: (e.glitchTimeSpan ? e.glitchTimeSpan.start : 0) * e.timing.duration, easing: "ease-in-out" }) } : null, x = (e) => {
  if (!e.shake)
    return { steps: [], timing: {} };
  const t = Math.floor(e.shake.velocity * e.timing.duration / 1e3) + 1, i = [];
  for (let r = 0; r < t; ++r) {
    const n = m(e, r / t) * e.shake.amplitudeX * 100, o = m(e, r / t) * e.shake.amplitudeY * 100;
    i.push({ transform: `translate3d(${n}%,${o}%,0)` });
  }
  return { steps: i, timing: u({ easing: `steps(${t},jump-start)` }, e.timing) };
}, b = (e) => [x(e), A(e), ...Array.from({ length: e.slice.count }).map(() => H(e))].filter((t) => t !== null), $ = (...e) => {
  const t = (i) => i && typeof i == "object";
  return e.reduce((i, r) => (Object.keys(r).forEach((n) => {
    t(i[n]) && t(r[n]) ? i[n] = $(i[n], r[n]) : r[n] !== void 0 && (i[n] = r[n]);
  }), i), {});
}, P = (e, t) => {
  var i, r;
  if (!t.createContainers)
    return { container: e, layersContainer: e, glitched: e.firstElementChild };
  if (!e.dataset.glitched) {
    const a = document.createElement("div"), l = document.createElement("div");
    return getComputedStyle(e).getPropertyValue("display").match(/^inline/) && (l.style.display = "inline-block"), l.appendChild(a), (i = e.parentElement) == null || i.insertBefore(l, e), a.prepend(e), { container: l, layersContainer: a, glitched: e };
  }
  const n = e.parentElement, o = (r = e.parentElement) == null ? void 0 : r.parentElement;
  for (; n.children.length > 1; )
    n.removeChild(n.children[1]);
  return n.firstElementChild.getAnimations().forEach((a) => a.cancel()), { container: o, layersContainer: n, glitched: e };
}, j = (e, t, i) => {
  const { glitched: r, container: n, layersContainer: o } = P(e, i);
  o.style.display = "grid", i.hideOverflow && (n.style.overflow = "hidden"), i.html && (r.innerHTML = i.html), r.style.gridArea = "1/1/-1/-1";
  const a = r.cloneNode(!0);
  a.dataset.islayer = "true", a.style.gridArea = "1/1/-1/-1", a.style.userSelect = "none", a.style.pointerEvents = "none", a.style.opacity = "0";
  for (let s = 0; s < t.length - 1; ++s) {
    const h = a.cloneNode(!0);
    o.appendChild(h);
  }
  const l = () => {
    t.forEach((s, h) => {
      o.children[h].animate(s.steps, s.timing);
    });
  }, c = () => {
    t.forEach((s, h) => {
      o.children[h].getAnimations().forEach((p) => {
        p.cancel();
      });
    });
  };
  switch (n.onmouseenter = null, n.onmouseleave = null, n.onclick = null, i.playMode) {
    case "always":
      l();
      break;
    case "hover":
      n.onmouseenter = l, n.onmouseleave = c;
      break;
    case "click":
      n.onclick = () => {
        c(), l();
      };
      break;
  }
  return e.dataset.glitched = "1", { container: n, startGlitch: l, stopGlitch: c };
}, T = (e = ".powerglitch", t = {}) => {
  const i = $(y(t.playMode), t);
  if (i.optimizeSeo && /google|bing|baidu|yandex|slurp|bot/i.exec(navigator.userAgent))
    return { containers: [], startGlitch: () => {
      console.warn("PowerGlitch disabled");
    }, stopGlitch: () => {
      console.warn("PowerGlitch disabled");
    } };
  let r = [];
  typeof e == "string" ? r = Array.from(document.querySelectorAll(e)) : e instanceof NodeList ? r = Array.from(e) : Array.isArray(e) ? r = e : e instanceof HTMLElement && (r = [e]);
  const n = b(i), o = r.filter((a) => !a.dataset.islayer).map((a) => j(a, n, i));
  return { containers: o.map((a) => a.container), startGlitch: () => o.forEach((a) => a.startGlitch()), stopGlitch: () => o.forEach((a) => a.stopGlitch()) };
}, L = { glitch: T, generateLayers: b, getDefaultOptions: y };
function W(e) {
  const [t, i] = d(e), [r, n] = d(() => () => {
  }), [o, a] = d(() => () => {
  });
  return {
    ref: E((c) => {
      if (!c)
        return;
      const s = L.glitch(c, t);
      n(() => s.startGlitch), a(() => s.stopGlitch);
    }, [t]),
    startGlitch: r,
    stopGlitch: o,
    setOptions: i
  };
}
export {
  W as useGlitch
};
